---
title: MyBatis ä¸­å‚æ•°åç§°è®¾ç½®è§„åˆ™æºç åˆ†æ
categories:
  - java-web
tags:
  - mybatis
abbrlink: '65881337'
date: 2018-09-29 23:29:53
updated: 2020-01-04 14:05:33
---

MyBatis æ˜¯æˆ‘ä»¬ç»å¸¸ä½¿ç”¨çš„ ORM æ¡†æ¶ï¼Œåœ¨ä½¿ç”¨çš„è¿‡ç¨‹ä¸­æˆ‘æœ€å®¹æ˜“å‡ºç°çš„é—®é¢˜å°±æ˜¯å‚æ•°æ²¡æœ‰ä¼ é€’æ­£ç¡®ï¼Œç„¶åæŠ›å‡ºå¼‚å¸¸è¯´æˆ‘ä»¬åœ¨ Mapper æ–‡ä»¶ä¸­ä½¿ç”¨çš„ä¸€äº›å‚æ•°æ²¡æœ‰æ‰¾åˆ°ã€‚ä¸€å¼€å§‹é‡åˆ°è¿™ç§é”™è¯¯è¿˜æŒºæ‡µçš„ï¼Œåæ¥é‡åˆ°å¤šäº†ä¹Ÿèƒ½å¾ˆå®¹æ˜“çš„æ‰¾å‡ºåŸå› ï¼Œç‰¹åˆ«æ˜¯åœ¨è¡¨å­—æ®µç»å¸¸å‘ç”Ÿé”™è¯¯çš„æƒ…å†µä¸‹ç‰¹åˆ«å®¹æ˜“å‡ºç°ã€‚ä½†æ˜¯å¯¹äº MyBatis å¦‚ä½•æ ¹æ® Mapper æ–‡ä»¶ä¸­å¼•ç”¨çš„å‚æ•°å¦‚ä½•åœ¨æ¥å£ä¸­æ‰¾åˆ°å¯¹åº”çš„å€¼ä¸€ç›´æ²¡æœ‰è¿›è¡Œè¿‡ç ”ç©¶ï¼Œç°åœ¨å¯¹ MyBatis ä¸­å‚æ•°çš„æ˜ å°„è§„åˆ™è¿›è¡Œè®°å½•ä¸€ä¸‹ã€‚

<!--more-->

ä¸€èˆ¬ä¸ºäº†èƒ½è®© Mapper æ–‡ä»¶ä¸­çš„å¼•ç”¨èƒ½æ­£ç¡®æ‰¾åˆ°æ¥å£ä¸­å‚æ•°ï¼Œæˆ‘ä»¬ä¼šåœ¨æ¥å£ä¸­çš„å‚æ•°ä¸Šæ·»åŠ ä¸Šâ€œ@Paramâ€æ³¨è§£ã€‚

* æ¥å£

```
void deleteVoucherRecord(@Param("orderId") int orderId, @Param("voucherType") int voucherType);
```

* Mapperæ–‡ä»¶

```
<update id="deleteVoucherRecord">
		UPDATE `voucher_record`
        SET `is_deleted` = 1
        WHERE
            `order_id` = #{orderId} AND `is_deleted` = 0 AND `voucher_category` =#{voucherType}
</update>
```
å¦‚æœæˆ‘ä»¬åœ¨æ¥å£ä¸­çš„å‚æ•°åˆ—è¡¨ä¸­ä½¿ç”¨æ³¨è§£ï¼Œé‚£ä¹ˆ MyBatis ä¼šæ ¹æ® Mapper æ–‡ä»¶ä¸­å¼•ç”¨çš„å‚æ•°åå»æ¥å£ä¸­å¯»æ‰¾ç›¸åº”å‚æ•°çš„å€¼ã€‚å¦‚æœæˆ‘ä»¬æ²¡æœ‰ä½¿ç”¨ â€œ@Paramâ€æ³¨è§£çš„è¯ MyBatis ä¼šä½¿ç”¨ä¸€å¥—å¦å¤–ä¸€å¥—è§„åˆ™ï¼Œä¸‹é¢æ ¹æ®æºç æ¥äº†è§£è¿™å¥—è§„åˆ™ã€‚

å› ä¸ºæˆ‘ä»¬å†™çš„æ¥å£æœ€ç»ˆä¼šè¢«ä»£ç†ï¼Œæ‰€ä»¥æˆ‘ä»¬ç›´æ¥çœ‹ org.apache.ibatis.binding.MapperProxy è¿™ä¸ªç±»ï¼Œå› ä¸ºæ¥å£ä¸­çš„æ–¹æ³•æœ€ç»ˆè¢«è°ƒç”¨æ—¶æœ€ç»ˆä¼šåœ¨å®ƒçš„ä»£ç†ç±»ä¸­æ‰§è¡Œã€‚

```
  @Override
  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    try {
      if (Object.class.equals(method.getDeclaringClass())) {
        return method.invoke(this, args);
      } else if (isDefaultMethod(method)) {
        return invokeDefaultMethod(proxy, method, args);
      }
    } catch (Throwable t) {
      throw ExceptionUtil.unwrapThrowable(t);
    }
    final MapperMethod mapperMethod = cachedMapperMethod(method);
    return mapperMethod.execute(sqlSession, args);
  }
```

æˆ‘ä»¬å¯ä»¥çœ‹å€’æ•°ç¬¬äºŒè¡Œä»£ç ï¼Œæ ¹æ®æ¥å£çš„ Method æ‰¾åˆ°å¯¹åº”çš„ MapperMethodï¼Œä¹Ÿå°±æ˜¯æ ¹æ®æ¥å£ä¸­çš„â€œdeleteVoucherRecordâ€æ–¹æ³•æ‰¾åˆ° Mapperæ–‡ä»¶ä¸­ id ä¸ºâ€œdeleteVoucherRecordâ€çš„ SQL è¯­å¥ã€‚

ä¸‹é¢æ¥çœ‹çœ‹ MapperMethod ç±»ä¸­çš„ execute æ–¹æ³•ï¼š

```
  public Object execute(SqlSession sqlSession, Object[] args) {
    Object result;
    switch (command.getType()) {
      case INSERT: {
    	Object param = method.convertArgsToSqlCommandParam(args);
        result = rowCountResult(sqlSession.insert(command.getName(), param));
        break;
      }
      case UPDATE: {
        Object param = method.convertArgsToSqlCommandParam(args);
        result = rowCountResult(sqlSession.update(command.getName(), param));
        break;
      }
      case DELETE: {
        Object param = method.convertArgsToSqlCommandParam(args);
        result = rowCountResult(sqlSession.delete(command.getName(), param));
        break;
      }
      case SELECT:
        if (method.returnsVoid() && method.hasResultHandler()) {
          executeWithResultHandler(sqlSession, args);
          result = null;
        } else if (method.returnsMany()) {
          result = executeForMany(sqlSession, args);
        } else if (method.returnsMap()) {
          result = executeForMap(sqlSession, args);
        } else if (method.returnsCursor()) {
          result = executeForCursor(sqlSession, args);
        } else {
          Object param = method.convertArgsToSqlCommandParam(args);
          result = sqlSession.selectOne(command.getName(), param);
          if (method.returnsOptional() &&
              (result == null || !method.getReturnType().equals(result.getClass()))) {
            result = Optional.ofNullable(result);
          }
        }
        break;
      case FLUSH:
        result = sqlSession.flushStatements();
        break;
      default:
        throw new BindingException("Unknown execution method for: " + command.getName());
    }
    if (result == null && method.getReturnType().isPrimitive() && !method.returnsVoid()) {
      throw new BindingException("Mapper method '" + command.getName() 
          + " attempted to return null from a method with a primitive return type (" + method.getReturnType() + ").");
    }
    return result;
  }
```

é€šè¿‡ä¸Šé¢çš„ä»£ç å¯ä»¥çœ‹åˆ°æˆ‘ä»¬ä»æ¥å£ä¸­ä¼ å…¥çš„å‚æ•°ç»è¿‡è½¬æ¢è¿”å›äº†ä¸€ä¸ª Objectï¼Œè‡³äº Object æ˜¯ä»€ä¹ˆæˆ‘ä»¬ç°åœ¨æ— æ³•çŸ¥é“ï¼Œæ‰€ä»¥ç»§ç»­è·Ÿè¿›ä»£ç è¿›è¡Œæ¨ç†ä¸éªŒè¯ã€‚

org.apache.ibatis.binding.MapperMethod.MethodSignature#convertArgsToSqlCommandParam ä»£ç å†…å®¹å¦‚ä¸‹ï¼š

```
    public Object convertArgsToSqlCommandParam(Object[] args) {
      return paramNameResolver.getNamedParams(args);
    }
```

è¿™æ®µä»£ç å—å¹¶æ²¡æœ‰ä»€ä¹ˆåŠŸèƒ½é€»è¾‘ï¼Œå®ƒå°†è¯¥åŠŸèƒ½å§”æ‰˜ç»™äº† org.apache.ibatis.reflection.ParamNameResolver ç±»æ¥å¤„ç†ï¼Œè¿™é‡Œå¯ä»¥çœ‹åˆ°å•ä¸€èŒè´£çš„è®¾è®¡æ¨¡å¼ï¼Œå°±è¡Œé¢†å¯¼ä¸ä¼šåšå¾ˆåº•å±‚çš„äº‹æƒ…ä¸€æ ·ï¼Œé¢†å¯¼åªéœ€è¦è´Ÿè´£æŒ‡æŒ¥ã€è°ƒæ§å°±è¡Œäº†ï¼Œå…·ä½“çš„æ´»å°±äº¤ç»™å°å¼Ÿå®Œæˆå°±è¡Œäº†ã€‚

org.apache.ibatis.reflection.ParamNameResolver#getNamedParams ä»£ç å†…å®¹å¦‚ä¸‹ï¼š

```
  /**
   * <p>
   * A single non-special parameter is returned without a name.
   * Multiple parameters are named using the naming rule.
   * In addition to the default names, this method also adds the generic names (param1, param2,
   * ...).
   * </p>
   */
  public Object getNamedParams(Object[] args) {
    final int paramCount = names.size();
    if (args == null || paramCount == 0) {
      return null;
    } else if (!hasParamAnnotation && paramCount == 1) {
      return args[names.firstKey()];
    } else {
      final Map<String, Object> param = new ParamMap<>();
      int i = 0;
      for (Map.Entry<Integer, String> entry : names.entrySet()) {
        param.put(entry.getValue(), args[entry.getKey()]);
        // add generic param names (param1, param2, ...)
        final String genericParamName = GENERIC_NAME_PREFIX + String.valueOf(i + 1);
        // ensure not to overwrite parameter named with @Param
        if (!names.containsValue(genericParamName)) {
          param.put(genericParamName, args[entry.getKey()]);
        }
        i++;
      }
      return param;
    }
  }
```

è¿™æ˜¯ MyBatis å‚æ•°æ˜ å°„é€»è¾‘å…³é”®ä»£ç ï¼Œä¸»è¦çš„é€»è¾‘éƒ½åœ¨è¿™é‡Œã€‚æˆ‘ä»¬å¯ä»¥çœ‹åˆ°æ ¹æ®ä¸åŒçš„æ¡ä»¶è¿”å›å€¼çš„ç±»å‹ä¹Ÿä¸ä¸€æ ·ã€‚

* é¦–å…ˆæ¥åˆ†æä¸€ä¸‹æ¥å£ä¸­æ²¡æœ‰ä½¿ç”¨æ³¨è§£å¹¶ä¸”å‚æ•°ä¸ªæ•°ä¸ºä¸€çš„æƒ…å†µï¼Œè¿”å›çš„å€¼æ˜¯â€œargs[names.firstKey]â€ï¼Œè¿™é‡Œâ€œnamesâ€æ˜¯ä¸€ä¸ªæˆå‘˜å˜é‡ï¼Œé‡Œé¢ä¿å­˜çš„æ˜¯æ¥å£ä¸­å‡½æ•°çš„å‚æ•°ä¿¡æ¯ï¼Œå®ƒçš„ç±»å‹æ˜¯ SortedMapã€Integer, Stringï¼Œä»è¿™é‡Œå¯ä»¥çœ‹åˆ°è¿™æ˜¯ä¸€ä¸ªæ’åºçš„ Mapï¼Œkey ä¿å­˜çš„æ˜¯å‡½æ•°ä¸­å‚æ•°çš„ä½ç½®ï¼Œvalue ä¿å­˜çš„æ˜¯å‡½æ•°ä¸­å‚æ•°çš„åç§°ï¼ˆå¦‚æœä½¿ç”¨äº†æ³¨è§£é‚£ä¹ˆ value å°±æ˜¯æ³¨è§£ä¸­çš„å€¼ï¼Œæ²¡æœ‰ä½¿ç”¨æ³¨è§£çš„è¯å°±æ˜¯ arg0ã€arg1ï¼‰ã€‚è¿™é‡Œéœ€è¦æ³¨æ„ä¸‹çš„æ˜¯æˆ‘ä»¬å…¶å®æ— æ³•é€šè¿‡åå°„æ‹¿åˆ°å‡½æ•°ä¸­å‚æ•°çš„çœŸæ˜¯åç§°ï¼Œæ‹¿åˆ°çš„å‚æ•°åç§°æ˜¯ arg0ã€arg1ï¼ˆè·ŸJDKç‰ˆæœ¬æœ‰å…³ï¼Œå¯æœ‰å¯èƒ½æ˜¯0ã€1ï¼‰ è¿™ç§å½¢å¼ï¼Œå½“ç„¶ JAVA8 å¯ä»¥é€šè¿‡åœ¨ç¼–è¯‘æ—¶æ·»åŠ â€œ-parametersâ€å‚æ•°å¯ä»¥è·å–åˆ°çœŸå®çš„å‚æ•°åï¼ŒMyBatis å¯¹è¿™ä¸ªç‰¹æ€§åœ¨ [3.4.1](https://github.com/mybatis/mybatis-3/releases) ä¸Šé¢æœ‰è¯´æ˜ï¼Œä½†æ˜¯æˆ‘æ²¡æœ‰è¿›è¡ŒéªŒè¯ï¼Œå¦‚æœè¯»è€…æœ‰å…´è¶£å¯ä»¥å»éªŒè¯ä¸‹ç»“æœç„¶åç•™è¨€å‘Šè¯‰æˆ‘ç»“æœğŸ˜ã€‚è¿™é‡Œä½œè€…è¿™æ ·å†™çš„æ„å›¾åº”è¯¥æ˜¯å¦‚æœåªæœ‰ä¸€ä¸ªå‚æ•°çŸ¥ä¸çŸ¥é“å‚æ•°çš„çœŸå®åç§°å·²ç»æ²¡æœ‰ä»€ä¹ˆæ„ä¹‰äº†ï¼Œå› ä¸ºå¯ä»¥è¿›è¡Œé€‰æ‹©çš„å‚æ•°ä¹Ÿå°±ä¸€ä¸ªä¸å­˜åœ¨æ˜ å°„é”™ä¹±çš„é—®é¢˜ã€‚

* å¦‚æœå‚æ•°ä¸ä¸ºç©ºå¹¶ä¸”ä½¿ç”¨äº†æ³¨è§£çš„æƒ…å†µä¸‹è¿”å›çš„ç»“æœæ˜¯ ParaMap ï¼Œè¿™æ˜¯ MyBatis ç»§æ‰¿ HashMap è‡ªå®šä¹‰çš„ Mapï¼Œè¦†å†™äº† get æ–¹æ³•ã€‚ParaMap çš„ key é¦–å…ˆä¼šä¿å­˜é€šè¿‡æ³¨è§£æˆ–è€…åå°„å›å»åˆ°å‚æ•°åï¼Œä¸æ­¤åŒæ—¶è¿˜ä¼šæ·»åŠ ä¸€ä¸ªé€šç”¨çš„å‚æ•°åâ€œgenericParamNameâ€ï¼Œç”Ÿæˆè§„åˆ™æ˜¯â€œGENERIC_NAME_PREFIX + String.valueOf(i + 1)â€ï¼Œè¿™é‡Œå¯ä»¥çœ‹åˆ°é€šç”¨å‚æ•°åçš„åç¼€æ˜¯ä»1å¼€å§‹ç®—çš„ã€‚

ä¸Šè¿°ä»£ç ä¸­â€œnames&â€æ˜¯ä¸€ä¸ªæ¯”è¾ƒé‡è¦çš„æˆå‘˜å˜é‡ï¼Œå®ƒæ˜¯åœ¨ ParamNameResolver ç±»çš„æ„é€ å‡½æ•°ä¸­è¿›è¡Œåˆå§‹åŒ–çš„ï¼Œå®ƒçš„åˆå§‹åŒ–ä¸ç”¨æˆ·çš„ä¸€é¡¹é…ç½®â€œuseActualParamNameâ€æœ‰å…³ï¼Œä»£ç å¦‚ä¸‹ï¼š

```
  public ParamNameResolver(Configuration config, Method method) {
    final Class<?>[] paramTypes = method.getParameterTypes();
    final Annotation[][] paramAnnotations = method.getParameterAnnotations();
    final SortedMap<Integer, String> map = new TreeMap<>();
    int paramCount = paramAnnotations.length;
    // get names from @Param annotations
    for (int paramIndex = 0; paramIndex < paramCount; paramIndex++) {
      if (isSpecialParameter(paramTypes[paramIndex])) {
        // skip special parameters
        continue;
      }
      String name = null;
      for (Annotation annotation : paramAnnotations[paramIndex]) {
        if (annotation instanceof Param) {
          hasParamAnnotation = true;
          name = ((Param) annotation).value();
          break;
        }
      }
      if (name == null) {
        // @Param was not specified.
        if (config.isUseActualParamName()) {
          name = getActualParamName(method, paramIndex);
        }
        if (name == null) {
          // use the parameter index as the name ("0", "1", ...)
          // gcode issue #71
          name = String.valueOf(map.size());
        }
      }
      map.put(paramIndex, name);
    }
    names = Collections.unmodifiableSortedMap(map);
  }
```

å¦‚æœæˆ‘ä»¬é…ç½®â€œuseActualNameâ€ä¸º trueï¼Œé‚£ä¹ˆ MyBatis ä¼šå°è¯•è·å–å‚æ•°çš„çœŸå®åç§°ï¼Œä½†æœ€ç»ˆæ˜¯å¦èƒ½è·å–åˆ°è·Ÿå…·ä½“çš„ JAVA Compiler æœ‰å…³ï¼Œæ‰€ä»¥å¦‚æœä¸æƒ³ä½¿ç”¨â€œ@Paramâ€æ³¨è§£ï¼Œè¿™é¡¹é…ç½®ä¹Ÿä¸èƒ½å°‘ã€‚